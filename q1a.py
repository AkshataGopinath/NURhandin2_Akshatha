"""# Question 1"""
import numpy as np
import matplotlib.pyplot as plt
print('###################### Question 1  ######################')

"""## 1a)"""

print('######### 1 (a) ##########')

def MWC(x, a = 4294957665):
    """ 
    Random number generator(RNG) using (Multip.) Linear Congruential Generator
    Inputs - 
    I0 : seed in range (0, 2**32)
    a,c,m: constants
    """
    # making the seed a 64 bit number
    # MWC formula
    x1 = np.uint64(a)*(np.uint64(x) & np.uint64(2**32 -1)) + (np.uint64(x) >> np.uint64(32))
    return x1

def XOR_shift(x, a1 = 21, a2 = 35, a3 = 4):
    """ 
    RNG using 64-bit XOR shift method
    x : seed
    a1, a2, a3 : constants 
    """
    x = np.uint64(x)
    x ^= np.uint64(x << np.uint64(a1)) 
    x ^= np.uint64(x >> np.uint64(a2)) 
    x ^= np.uint64(x << np.uint64(a3)) 
    return x

def random_():
    """
    Function combining XOR shift and MLCG
    """
    global seed
    seed_xor = MWC(seed)
    # feeding random number generated by XOR shift method as seed to MLCG
    rand = XOR_shift(seed_xor)
    # updating seed for MWC in the next iteration, as the lowest 32 bits of random number generated by xor-shift. 
    seed = rand
    return rand

def random( a, b, n):
    """ 
    Function to generate random numbers between (0,1) by combining MLCG and XOR shift
    Inputs-
    (a, b) : range in which you want the random numbers
    n : number of random numbers to be generated
    """
    #combining XOR shift and MLCG
    nos = [random_() for _ in range(n)]

    #to ensure all numbers lie in (0, 1), maximum possible number that can be generated is 2**64
    max_rand = 2**64
    U01 = np.array(nos) / max_rand
    # making the uniform distribution lie in the specified range (a,b)
    return np.array((U01*(b-a)) + a, dtype='f')


# seed for the random number generator
seed = 4294957665
print('seed for RNG is', seed)
rng_arr = random(0, 1, 1000000)
def qn1a():
	# scatter plot of (x(i+1) and x(i))
	plt.figure()
	plt.scatter(rng_arr[0:1000],rng_arr[1:1001])
	plt.title('Scatter plot of sequential random number plotted against each other(first 1000 numbers): \n The scatter plot shows that the generated random numbers are uncorrelated since we see no pattern')
	plt.xlabel('x[i]')
	plt.ylabel('x[i+1]')
	plt.savefig('RNGscatter.png',  bbox_inches = "tight")

	# plot of value of random number vs its index#       # since erf is an odd function
	#       elif x1[i]<0: 
	#           x2 = -x1[i]
	#           t= 1/(1 + p*x2)
	#           val = -(1 - ((a1*t + a2*t**2 + a3*t**3)*np.exp(-x2**2)))

	#       valss.append(val)
			
	plt.figure()
	plt.plot(rng_arr[0:1000])
	plt.title('plot of value of random number x[i] vs its index i')
	plt.xlabel('i')
	plt.ylabel('x[i]')
	plt.savefig('RNs.png')


	# binning in 20bins each 0.05 wide, and plotting 
	plt.figure()
	plt.hist(rng_arr, bins= np.linspace(0,1,21), edgecolor='black', linewidth=1.5)
	plt.title('Histogram of 1000000 uniformly sampled random numbers in (0,1) in bins of width 0.05: \n the histogram more or less is flat with a mean at 50000, \n and no bins with deviation over 1sigma (sigma = sqrt(mean)), \n showing that the generated random number are uniformly distributed')
	plt.xlabel('bins')
	plt.ylabel('frequency')
	plt.savefig('RNGhist.png', bbox_inches = "tight")
	
if __name__ == '__main__':
	print('1 (a):')
	qn1a()
	
